<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kur'an-ƒ± Kerim Kelime K√∂k Uzayƒ±</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><circle cx='16' cy='16' r='14' fill='%23000' stroke='%2300f2ff' stroke-width='2'/><circle cx='16' cy='16' r='4' fill='%2300f2ff'/></svg>">
    <script>const _w=console.warn;console.warn=(...a)=>{if(typeof a[0]==='string'&&a[0].includes('tailwindcss.com'))return;_w.apply(console,a);};</script>
    <script src="tailwind.min.js"></script>
    <script src="three.min.js"></script>
    <script src="OrbitControls.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=Amiri&display=swap');
        
        body { margin: 0; background: #000; color: white; font-family: 'Inter', sans-serif; overflow: hidden; }
        canvas { display: block; }

        .hud-panel {
            background: rgba(0, 5, 12, 0.98);
            backdrop-filter: blur(40px);
            border-left: 3px solid #00f2ff;
            box-shadow: -25px 0 100px rgba(0,0,0,1);
            pointer-events: auto;
            -webkit-overflow-scrolling: touch;
        }

        @media (max-width: 767px) {
            .hud-panel { border-left: none; border-top: 3px solid #00f2ff; }
            .root-badge { min-width: 60px; padding: 8px; }
            .root-pron { font-size: 7px; }
            .ayah-list-item { padding: 10px; }
            .ayah-list-item:hover { transform: none; }
        }

        .search-results {
            position: absolute; top: 100%; left: 0; right: 0;
            background: rgba(0, 8, 15, 0.98); border: 1px solid rgba(0, 242, 255, 0.3);
            border-radius: 20px; margin-top: 10px; max-height: min(480px, 60vh); overflow-y: auto;
            display: none; z-index: 100; backdrop-filter: blur(20px);
        }
        .search-stats-bar {
            padding: 12px 20px; background: rgba(0, 242, 255, 0.15);
            border-bottom: 1px solid rgba(0, 242, 255, 0.3);
            font-size: 10px; font-weight: 900; color: #00f2ff;
            text-transform: uppercase; letter-spacing: 2px;
            display: flex; justify-content: space-between;
            position: sticky; top: 0; z-index: 110;
        }

        .neon-title {
            color: #00f2ff; font-weight: 900; text-transform: uppercase;
            font-style: italic; letter-spacing: -1px;
            text-shadow: 0 0 20px rgba(0, 242, 255, 0.6);
        }

        .root-badge {
            padding: 14px 16px; border-radius: 14px; min-width: 90px;
            background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1);
            display: flex; flex-direction: column; align-items: center; 
            box-shadow: 0 0 15px currentColor;
        }
        .root-pron { font-size: 10px; font-weight: 900; letter-spacing: 1.5px; margin-top: 6px; opacity: 0.8; text-transform: uppercase; color: white; }

        .arabic-text { font-family: 'Amiri', serif; line-height: 1.8; word-spacing: 4px; }
        .root-highlight { 
            text-shadow: 0 0 8px currentColor, 0 0 20px currentColor; 
            font-weight: bold;
            display: inline-block; transition: all 0.4s;
            border-bottom: 2px solid currentColor;
            background: rgba(255,255,255,0.06);
            padding: 0 2px;
            border-radius: 3px;
        }

        #tooltip {
            position: fixed; display: none; pointer-events: none;
            background: rgba(0, 5, 12, 0.98); border: 1px solid rgba(0, 242, 255, 0.4);
            padding: 24px; max-width: min(520px, calc(100vw - 32px)); z-index: 1000;
            max-height: calc(100vh - 32px); overflow-y: auto;
            box-shadow: 0 25px 80px rgba(0,0,0,1); backdrop-filter: blur(25px);
            border-radius: 1.5rem;
        }

        .ayah-list-item { 
            padding: 14px; border-radius: 15px; background: rgba(255,255,255,0.02); 
            border: 1px solid rgba(255,255,255,0.05); margin-bottom: 10px; 
            cursor: pointer; transition: all 0.3s; 
        }
        .ayah-list-item:hover { background: rgba(0, 242, 255, 0.1); border-color: #00f2ff; transform: translateX(10px); }
        
        .mini-root-tag { 
            font-size: 16px; padding: 6px 12px; border-radius: 8px; border: 1px solid; 
            margin-right: 5px; margin-top: 6px; display: inline-flex; 
            flex-direction: column; align-items: center; font-weight: 900; 
            background: rgba(0,0,0,0.4); line-height: 1.2;
            text-shadow: 0 0 6px currentColor;
        }
        .mini-root-pron { 
            font-size: 9px; letter-spacing: 0.8px; opacity: 0.8; 
            margin-top: 3px; color: #fff; text-transform: uppercase; font-family: 'Inter', sans-serif;
        }

        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-thumb { background: #00f2ff; border-radius: 10px; }

        .loading-screen {
            position: fixed; inset: 0; background: #000; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s;
        }
    </style>
</head>
<body>

    <div id="loading-screen" class="loading-screen">
        <div class="w-16 h-16 border-4 border-cyan-500 border-t-transparent rounded-full animate-spin mb-6 shadow-[0_0_20px_rgba(6,182,212,0.5)]"></div>
        <p class="text-cyan-500 font-mono tracking-[0.5em] text-xs uppercase animate-pulse">Y√ºkleniyor...</p>
    </div>

    <canvas id="warp-canvas" style="position:fixed;inset:0;pointer-events:none;z-index:998;display:none;"></canvas>
    <div id="tooltip"></div>

    <div class="fixed top-0 w-full z-50 p-3 md:p-6 flex flex-col md:flex-row justify-between items-center bg-gradient-to-b from-black to-transparent gap-2 md:gap-4">
        <div class="text-center md:text-left">
            <h1 class="text-xl md:text-3xl neon-title">Kur'an-ƒ± Kerim Kelime K√∂k Uzayƒ±</h1>
            <p class="text-[8px] md:text-[9px] text-cyan-800 font-mono tracking-[0.4em] uppercase">3D Semantik Analiz</p>
        </div>
        <div class="flex flex-col sm:flex-row gap-2 md:gap-3 w-full md:w-auto relative">
            <div class="w-full md:w-[32rem] relative">
                <input type="text" id="search-input" placeholder="Sure, Koordinat veya Meal Ara..." class="bg-black/90 border border-white/10 rounded-full px-4 md:px-7 py-2.5 md:py-3 w-full outline-none focus:border-cyan-400 text-xs md:text-sm font-bold text-white shadow-2xl transition-all">
                <div id="search-results" class="search-results"></div>
            </div>
            <label id="upload-label" class="bg-cyan-950 hover:bg-cyan-600 border border-cyan-400/30 px-4 md:px-8 py-2.5 md:py-3 rounded-full font-black text-[10px] md:text-[11px] cursor-pointer shadow-xl transition-all uppercase text-white tracking-widest text-center">
                VERƒ∞ Y√úKLE
                <input type="file" id="file-input" class="hidden" accept=".json">
            </label>
        </div>
    </div>

    <div id="hud-panel" class="fixed inset-2 top-20 md:inset-auto md:top-28 md:bottom-8 md:left-8 md:w-[28rem] hud-panel rounded-2xl md:rounded-[3.5rem] p-4 md:p-10 hidden z-40 overflow-y-auto border border-white/5 transition-all duration-300">
        <button id="close-hud" class="absolute top-3 right-3 md:top-10 md:right-10 w-9 h-9 md:w-10 md:h-10 flex items-center justify-center bg-white/5 rounded-full text-slate-500 hover:text-white transition-all z-50">‚úï</button>
        <div id="hud-content">
            <div class="mb-6 md:mb-8 border-b border-white/10 pb-6 md:pb-8">
                <h2 id="hud-title" class="text-3xl md:text-4xl neon-title">SURE</h2>
                <p id="hud-coord" class="text-[9px] md:text-[10px] text-slate-500 font-mono tracking-[0.4em] mt-2 uppercase opacity-60">KOORDƒ∞NAT: 0:0</p>
            </div>

            <div class="bg-slate-900/60 p-4 md:p-8 rounded-xl md:rounded-[2.5rem] mb-4 md:mb-8 border border-white/5 shadow-inner">
                <p id="hud-arabic" class="text-right text-xl md:text-3xl arabic-text text-white leading-relaxed" dir="rtl"></p>
                <div class="h-px w-full bg-cyan-400/20 my-3 md:my-6"></div>
                <p id="hud-translation" class="text-sm md:text-lg text-slate-200 italic font-light leading-relaxed"></p>
            </div>

            <div class="mb-6 md:mb-8">
                <h3 class="text-[8px] md:text-[9px] font-black text-slate-600 uppercase tracking-[0.4em] mb-4 md:mb-6 italic text-center">S√ºl√¢si K√∂k Analizi</h3>
                <div id="hud-roots" class="flex flex-wrap justify-center gap-2 md:gap-4"></div>
            </div>

            <div class="pb-8">
                <h3 class="text-[9px] font-black text-cyan-950 uppercase tracking-[0.4em] mb-4 italic text-center">Semantik Baƒülantƒ±lar</h3>
                <input type="text" id="hud-search" placeholder="Ayet, sure veya k√∂k ara..." class="w-full bg-black/60 border border-white/10 rounded-full px-5 py-2 mb-4 outline-none focus:border-cyan-400 text-xs text-white placeholder-slate-600 font-mono">
                <div id="related-list"></div>
            </div>
        </div>
    </div>

    <script>
        /** GLOBAL VARIABLES **/
        let scene, camera, renderer, ayahMesh, starField, lineSegments, controls, highlightLines;
        let nodes = []; let surahGroups = []; let ayahNodes = []; let rootMap = new Map(); let labelSprites = []; let lineNodePairs = [];

        // Glow shader (fresnel atmosfer efekti)
        const glowVertexShader = `
            varying vec3 vNormal;
            varying vec3 vPositionNormal;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPositionNormal = normalize((modelViewMatrix * vec4(position, 1.0)).xyz);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        const glowFragmentShader = `
            uniform vec3 glowColor;
            uniform float intensity;
            uniform float time;
            varying vec3 vNormal;
            varying vec3 vPositionNormal;
            void main() {
                float rim = pow(intensity - dot(vNormal, vPositionNormal), 3.0);
                float pulse = 0.85 + 0.15 * sin(time * 2.0);
                gl_FragColor = vec4(glowColor, rim * pulse);
            }
        `;
        // Prosed√ºrel neon g√ºl texture √ºretici (tort√ºl√º/grainy)
        const createSunTexture = (baseColor, size) => {
            size = size || 512;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            const cx = size / 2, cy = size / 2, r = size / 2;
            const R = baseColor.r * 255 | 0, G = baseColor.g * 255 | 0, B = baseColor.b * 255 | 0;

            // Koyu arka plan
            ctx.fillStyle = `rgb(${R * 0.08 | 0},${G * 0.08 | 0},${B * 0.15 | 0})`;
            ctx.fillRect(0, 0, size, size);

            // Merkez yumu≈üak parlama
            const core = ctx.createRadialGradient(cx, cy, 0, cx, cy, r * 0.7);
            core.addColorStop(0, `rgba(${R * 0.4 | 0},${G * 0.4 | 0},${B * 0.6 | 0},0.6)`);
            core.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = core;
            ctx.fillRect(0, 0, size, size);

            // Neon girdap damarlarƒ± (g√ºl yapraklarƒ± benzeri)
            ctx.globalCompositeOperation = 'lighter';
            for (let i = 0; i < 18; i++) {
                ctx.beginPath();
                const startAngle = (i / 18) * Math.PI * 2 + Math.random() * 0.5;
                const spiralR = r * (0.2 + Math.random() * 0.6);
                let px = cx, py = cy;
                ctx.moveTo(px, py);
                for (let t = 0; t < 40; t++) {
                    const a = startAngle + t * 0.15 + Math.sin(t * 0.3) * 0.5;
                    const rd = spiralR * (t / 40);
                    px = cx + Math.cos(a) * rd + (Math.random() - 0.5) * 8;
                    py = cy + Math.sin(a) * rd + (Math.random() - 0.5) * 8;
                    ctx.lineTo(px, py);
                }
                const brightness = 0.5 + Math.random() * 0.5;
                ctx.strokeStyle = `rgba(${Math.min(255, R * 1.8) | 0},${Math.min(255, G * 1.8) | 0},${Math.min(255, B * 2) | 0},${brightness * 0.4})`;
                ctx.lineWidth = 1 + Math.random() * 2.5;
                ctx.shadowColor = `rgb(${Math.min(255, R * 1.5) | 0},${Math.min(255, G * 1.5) | 0},${Math.min(255, B * 2) | 0})`;
                ctx.shadowBlur = 6 + Math.random() * 10;
                ctx.stroke();
            }

            // Yaprak benzeri kavisli ≈üekiller
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                const a0 = Math.random() * Math.PI * 2;
                const petalR = r * (0.3 + Math.random() * 0.4);
                const px0 = cx + Math.cos(a0) * petalR * 0.3;
                const py0 = cy + Math.sin(a0) * petalR * 0.3;
                const px1 = cx + Math.cos(a0 + 0.5) * petalR;
                const py1 = cy + Math.sin(a0 + 0.5) * petalR;
                const px2 = cx + Math.cos(a0 + 1.0) * petalR * 0.3;
                const py2 = cy + Math.sin(a0 + 1.0) * petalR * 0.3;
                ctx.moveTo(px0, py0);
                ctx.quadraticCurveTo(px1, py1, px2, py2);
                ctx.strokeStyle = `rgba(${Math.min(255, R * 1.6) | 0},${Math.min(255, G * 1.6) | 0},${Math.min(255, B * 2.2) | 0},${0.25 + Math.random() * 0.25})`;
                ctx.lineWidth = 1.5 + Math.random() * 2;
                ctx.shadowBlur = 12;
                ctx.stroke();
            }
            ctx.shadowBlur = 0;

            // Kenar neon parlamasƒ±
            const edge = ctx.createRadialGradient(cx, cy, r * 0.5, cx, cy, r);
            edge.addColorStop(0, 'rgba(0,0,0,0)');
            edge.addColorStop(0.7, `rgba(${R * 0.3 | 0},${G * 0.3 | 0},${B * 0.8 | 0},0.15)`);
            edge.addColorStop(1, `rgba(${Math.min(255, R * 1.2) | 0},${Math.min(255, G * 1.2) | 0},${Math.min(255, B * 1.5) | 0},0.4)`);
            ctx.fillStyle = edge;
            ctx.fillRect(0, 0, size, size);

            // Tort√ºl√º / grainy noise
            const imgData = ctx.getImageData(0, 0, size, size);
            const d = imgData.data;
            for (let i = 0; i < d.length; i += 4) {
                const noise = (Math.random() - 0.5) * 30;
                d[i] = Math.max(0, Math.min(255, d[i] + noise));
                d[i+1] = Math.max(0, Math.min(255, d[i+1] + noise));
                d[i+2] = Math.max(0, Math.min(255, d[i+2] + noise));
            }
            ctx.putImageData(imgData, 0, 0);
            ctx.globalCompositeOperation = 'source-over';

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.needsUpdate = true;
            return tex;
        };

        let raycaster = new THREE.Raycaster(); let mouse = new THREE.Vector2();
        let currentAudio = null; let audioCache = new Map(); let hoverTimeout = null; let lastHoveredId = null;
        let warpActive = false; let warpProgress = 0; let warpStart = new THREE.Vector3(); let warpEnd = new THREE.Vector3(); let warpTarget = new THREE.Vector3();
        let warpCanvas, warpCtx, warpStars = [], warpSpeed = 1, warpCenterX = 0, warpCenterY = 0;
        let isAudioLoading = false;
        
        // --- ‚ö†Ô∏è API KEY BURAYA GELECEK ---
        const apiKey = "AIzaSyABgS_0iV7VnlZY5MwqxpM5sksMmqh9LFA"; 

        const arabicToLatinMap = {
            'ÿß': 'E', 'ÿ£': 'E', 'ÿ•': 'E', 'ÿ¢': 'E', 'ÿ®': 'B', 'ÿ™': 'T', 'ÿ´': 'TH', 'ÿ¨': 'C', 'ÿ≠': 'H', 'ÿÆ': 'KH', 
            'ÿØ': 'D', 'ÿ∞': 'DH', 'ÿ±': 'R', 'ÿ≤': 'Z', 'ÿ≥': 'S', 'ÿ¥': '≈û', 'ÿµ': 'S', 
            'ÿ∂': 'D', 'ÿ∑': 'T', 'ÿ∏': 'Z', 'ÿπ': 'A', 'ÿ∫': 'GH', 'ŸÅ': 'F', 'ŸÇ': 'K', 
            'ŸÉ': 'K', 'ŸÑ': 'L', 'ŸÖ': 'M', 'ŸÜ': 'N', 'Ÿá': 'H', 'Ÿà': 'V', 'Ÿä': 'Y', 
            'ÿ°': 'E', 'ÿ§': 'W', 'ÿ¶': 'Y', 'ÿ©': 'T', ' ' : '-'
        };

        const surahNamesTR = {
            "1":"F√¢tiha","2":"Bakara","3":"√Çl-i ƒ∞mr√¢n","4":"Nis√¢","5":"M√¢ide","6":"En'√¢m","7":"A'r√¢f","8":"Enf√¢l","9":"Tevbe","10":"Y√ªnus",
            "11":"H√ªd","12":"Y√ªsuf","13":"Ra'd","14":"ƒ∞br√¢h√Æm","15":"Hicr","16":"Nahl","17":"ƒ∞sr√¢","18":"Kehf","19":"Meryem","20":"T√¢-H√¢",
            "21":"Enbiy√¢","22":"Hac","23":"M√º'min√ªn","24":"N√ªr","25":"Furk√¢n","26":"≈ûuar√¢","27":"Neml","28":"Kasas","29":"Ankeb√ªt","30":"R√ªm",
            "31":"Lokm√¢n","32":"Secde","33":"Ahz√¢b","34":"Sebe'","35":"F√¢tƒ±r","36":"Y√¢-S√Æn","37":"S√¢ff√¢t","38":"S√¢d","39":"Z√ºmer","40":"M√º'min",
            "41":"Fussilet","42":"≈û√ªr√¢","43":"Zuhruf","44":"Duh√¢n","45":"C√¢siye","46":"Ahk√¢f","47":"Muhammed","48":"Fetih","49":"Hucur√¢t","50":"K√¢f",
            "51":"Z√¢riy√¢t","52":"T√ªr","53":"Necm","54":"Kamer","55":"Rahm√¢n","56":"V√¢kƒ±a","57":"Had√Æd","58":"M√ºc√¢dele","59":"Ha≈ür","60":"M√ºmtehine",
            "61":"Saff","62":"Cuma","63":"M√ºn√¢fik√ªn","64":"Teg√¢bun","65":"Tal√¢k","66":"Tahr√Æm","67":"M√ºlk","68":"Kalem","69":"H√¢kka","70":"Me√¢ric",
            "71":"N√ªh","72":"Cin","73":"M√ºzzemmil","74":"M√ºddessir","75":"Kƒ±y√¢met","76":"ƒ∞ns√¢n","77":"M√ºrsel√¢t","78":"Nebe","79":"N√¢zi√¢t","80":"Abese",
            "81":"Tekv√Ær","82":"ƒ∞nfit√¢r","83":"Mutaffif√Æn","84":"ƒ∞n≈üik√¢k","85":"Bur√ªc","86":"T√¢rƒ±k","87":"A'l√¢","88":"G√¢≈üiye","89":"Fecr","90":"Beled",
            "91":"≈ûems","92":"Leyl","93":"Duh√¢","94":"ƒ∞n≈üir√¢h","95":"T√Æn","96":"Alak","97":"Kadir","98":"Beyyine","99":"Zilz√¢l","100":"√Çdiy√¢t",
            "101":"K√¢ria","102":"Tek√¢s√ºr","103":"Asr","104":"H√ºmeze","105":"F√Æl","106":"Kurey≈ü","107":"M√¢√ªn","108":"Kevser","109":"K√¢fir√ªn","110":"Nasr",
            "111":"Mesed","112":"ƒ∞hl√¢s","113":"Felak","114":"N√¢s"
        };

        const getSurahTR = (id) => surahNamesTR[id.split(':')[0]] || "Sure " + id.split(':')[0];
        const getRootCSSColor = (root) => {
            let h = 0; for (let i = 0; i < root.length; i++) h = (h << 5) - h + root.charCodeAt(i);
            return `hsl(${Math.abs(h * 137.5) % 360}, 100%, 60%)`;
        };
        const getRootPron = (root) => {
            if(!root) return "";
            return root.split('').filter(c => c !== ' ').map(char => arabicToLatinMap[char] || char).join('-');
        };

        const highlightArabicText = (text, roots) => {
            if (!roots || roots.length === 0) return text;
            const diacritics = /[Ÿã-ŸüŸ∞€ñ-€≠]/g;
            const alifV = /[ÿßÿ£ÿ•ÿ¢ÿ°]/g;
            let clean = ""; let map = [];
            for (let i = 0; i < text.length; i++) {
                if (!text[i].match(diacritics)) { map.push(i); clean += text[i]; }
            }
            let res = text; let matches = [];
            roots.forEach(root => {
                if(!root) return;
                const color = getRootCSSColor(root);
                const cleanRoot = root.trim().replace(diacritics, '').replace(alifV, 'ÿß').replace(/\s/g, '');
                if (!cleanRoot) return;
                let src = clean.replace(alifV, 'ÿß');
                let start = 0;
                while ((start = src.indexOf(cleanRoot, start)) !== -1) {
                    const os = map[start];
                    const oe = map[start + cleanRoot.length] ? map[start + cleanRoot.length] - 1 : text.length - 1;
                    matches.push({ s: os, e: oe, color: color });
                    start += cleanRoot.length;
                }
            });
            matches.sort((a, b) => b.s - a.s);
            matches.forEach(m => {
                const sub = res.substring(m.s, m.e + 1);
                res = res.slice(0, m.s) + `<span class="root-highlight" style="color: ${m.color}">${sub}</span>` + res.slice(m.e + 1);
            });
            return res;
        };

        const stopAudio = () => { if (currentAudio) { currentAudio.pause(); currentAudio.currentTime = 0; currentAudio = null; } };
        const playAudio = (url) => { if (currentAudio) stopAudio(); currentAudio = new Audio(url); currentAudio.play().catch(e => {}); };

        const speakAyah = async (text) => {
            if (!apiKey) { console.warn('TTS: API key tanƒ±mlanmamƒ±≈ü'); return false; }
            stopAudio();
            if (audioCache.has(text)) { playAudio(audioCache.get(text)); return true; }
            if (isAudioLoading) return false;
            isAudioLoading = true;
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: `Say in Turkish: ${text}` }] }],
                        generationConfig: { responseModalities: ["AUDIO"], speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Charon" } } } },
                        model: "gemini-2.5-flash-preview-tts"
                    })
                });
                if (!response.ok) { console.error('TTS API hata:', response.status, response.statusText); return false; }
                const result = await response.json();
                const part = result.candidates?.[0]?.content?.parts?.[0];
                if (part?.inlineData?.data) {
                    const raw = window.atob(part.inlineData.data);
                    const pcm = new Uint8Array(raw.length);
                    for (let i = 0; i < raw.length; i++) pcm[i] = raw.charCodeAt(i);
                    const url = URL.createObjectURL(new Blob([pcmToWav(pcm, 24000)], { type: 'audio/wav' }));
                    audioCache.set(text, url);
                    playAudio(url);
                    return true;
                }
                console.warn('TTS: Ses verisi alƒ±namadƒ±', result);
                return false;
            } catch (err) { console.error('TTS hata:', err); return false; } finally { isAudioLoading = false; }
        };

        const pcmToWav = (pcm, rate) => {
            const b = new ArrayBuffer(44 + pcm.length); const v = new DataView(b);
            const s = (o, str) => { for (let i = 0; i < str.length; i++) v.setUint8(o + i, str.charCodeAt(i)); };
            s(0, 'RIFF'); v.setUint32(4, 36 + pcm.length, true); s(8, 'WAVE'); s(12, 'fmt '); v.setUint32(16, 16, true);
            v.setUint16(20, 1, true); v.setUint16(22, 1, true); v.setUint32(24, rate, true); v.setUint32(28, rate * 2, true);
            v.setUint16(32, 2, true); v.setUint16(34, 16, true); s(36, 'data'); v.setUint32(40, pcm.length, true);
            for (let i = 0; i < pcm.length; i++) v.setUint8(44 + i, pcm[i]); return b;
        };

        const init = () => {
            scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 1, 100000000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); document.body.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true;
            scene.add(new THREE.AmbientLight(0xffffff, 1.4));
            const starGeom = new THREE.BufferGeometry(); const starPos = [];
            for(let i=0; i<60000; i++) starPos.push((Math.random()-0.5)*60000000, (Math.random()-0.5)*60000000, (Math.random()-0.5)*60000000);
            starGeom.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            starField = new THREE.Points(starGeom, new THREE.PointsMaterial({ color: 0x888888, size: 1600, transparent: true, opacity: 0.5 }));
            scene.add(starField); camera.position.set(0, 10000000, 20000000);

            // Canvas2D Hyperspace warp sistemi
            warpCanvas = document.getElementById('warp-canvas');
            warpCtx = warpCanvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            warpCanvas.width = window.innerWidth * dpr;
            warpCanvas.height = window.innerHeight * dpr;
            warpCanvas.style.width = window.innerWidth + 'px';
            warpCanvas.style.height = window.innerHeight + 'px';
            warpCtx.scale(dpr, dpr);
            warpCenterX = window.innerWidth / 2;
            warpCenterY = window.innerHeight / 2;
            for (let i = 0; i < 6000; i++) {
                warpStars.push({
                    x: Math.random() * window.innerWidth * 4 - window.innerWidth * 2,
                    y: Math.random() * window.innerHeight * 4 - window.innerHeight * 2,
                    z: Math.random() * window.innerWidth,
                    pz: 0, size: Math.random() * 2.0 + 0.5
                });
            }
            scene.add(camera);
            renderer.domElement.addEventListener('click', onMouseClick); 
            window.addEventListener('mousemove', onMouseMove); 
            animate();
            
            // --- OTOMATƒ∞K VERƒ∞ √áEKME (GitHub Pages Desteƒüi) ---
            fetchDataAutomatically();
        };

        const fetchDataAutomatically = async () => {
            try {
                const response = await fetch('quran_data.json');
                if (response.ok) {
                    const data = await response.json();
                    processData(data);
                    document.getElementById('upload-label').style.display = 'none';
                }
            } catch (e) {
                console.log("JSON bulunamadƒ±, manuel y√ºkleme bekleniyor.");
            } finally {
                setTimeout(() => {
                    document.getElementById('loading-screen').style.opacity = '0';
                    setTimeout(() => document.getElementById('loading-screen').style.display = 'none', 800);
                }, 1000);
            }
        };

        const createTextSprite = (text, isSurah) => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512; canvas.height = 64;
            ctx.font = `bold ${isSurah ? 40 : 30}px Inter, sans-serif`;
            ctx.fillStyle = isSurah ? '#00f2ff' : '#ffffff';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            const texture = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
            const sprite = new THREE.Sprite(mat);
            const s = isSurah ? 5000 : 3000;
            sprite.scale.set(s, s * (canvas.height / canvas.width), 1);
            return sprite;
        };

        const processData = (data) => {
            if (!data || !data.nodes) return;
            surahGroups.forEach(g => scene.remove(g)); if(ayahMesh) scene.remove(ayahMesh); if(lineSegments) scene.remove(lineSegments);
             labelSprites.forEach(s => scene.remove(s));
             surahGroups = []; ayahNodes = []; rootMap.clear(); labelSprites = []; lineNodePairs = [];
            nodes = data.nodes.map(n => ({ ...n, roots: Array.isArray(n.roots) ? n.roots : [] }));
            const surahIds = [...new Set(nodes.map(n => n.id.split(':')[0]))].sort((a,b) => parseInt(a)-parseInt(b));

            // Samanyolu Galaksisi spiral parametreleri
            const totalTurns = 4;
            const maxRadius = 25000000;
            const ayahScatterR = 60000;
            const diskThickness = 300000;

            // Surah ba≈üƒ±na ayet sayƒ±sƒ±
            const surahAyahCounts = {};
            surahIds.forEach(sid => {
                surahAyahCounts[sid] = nodes.filter(n => n.id.split(':')[0] === sid).length;
            });

            // Surah pozisyonlarƒ±: Ar≈üimed spiralƒ± (Fatiha merkezde)
            const surahPosMap = {};
            surahIds.forEach((sid, sIdx) => {
                const t = sIdx / Math.max(surahIds.length - 1, 1);
                const theta = t * totalTurns * Math.PI * 2;
                const r = t * maxRadius;
                surahPosMap[sid] = { x: Math.cos(theta) * r, z: Math.sin(theta) * r };
            });

            const lineV = []; const lineC = [];

            nodes.forEach((node, idx) => {
                const parts = node.id.split(':');
                const surahNum = parts[0];
                const ayahNum = parseInt(parts[1]);
                const sp = surahPosMap[surahNum];

                if (ayahNum === 1) {
                    // Sure merkez node: galaktik d√ºzlemde
                    node.x = sp.x; node.y = 0; node.z = sp.z;
                    const g = new THREE.Group();
                    g.position.set(node.x, node.y, node.z);
                    g.userData = { nodeData: node };
                    const c = new THREE.Color(getRootCSSColor(surahNum));
                    const sunTex = createSunTexture(c, 512);

                    // ƒ∞√ß √ßekirdek k√ºre (texture'lƒ±)
                    const coreMat = new THREE.MeshBasicMaterial({ map: sunTex });
                    const core = new THREE.Mesh(new THREE.SphereGeometry(1500, 64, 64), coreMat);
                    core.renderOrder = 2;
                    g.add(core);

                    // Glow katmanƒ± (fresnel blur efekti)
                    const glowMat = new THREE.ShaderMaterial({
                        uniforms: {
                            glowColor: { value: c },
                            intensity: { value: 0.45 },
                            time: { value: 0.0 }
                        },
                        vertexShader: glowVertexShader,
                        fragmentShader: glowFragmentShader,
                        side: THREE.BackSide,
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                        depthWrite: false
                    });
                    const glow = new THREE.Mesh(new THREE.SphereGeometry(2000, 32, 32), glowMat);
                    glow.renderOrder = 0;
                    g.add(glow);

                    // Dƒ±≈ü halo (yumu≈üak parlama)
                    const haloMat = new THREE.ShaderMaterial({
                        uniforms: {
                            glowColor: { value: c },
                            intensity: { value: 0.25 },
                            time: { value: 0.0 }
                        },
                        vertexShader: glowVertexShader,
                        fragmentShader: glowFragmentShader,
                        side: THREE.BackSide,
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                        depthWrite: false
                    });
                    const halo = new THREE.Mesh(new THREE.SphereGeometry(2800, 32, 32), haloMat);
                    halo.renderOrder = 0;
                    g.add(halo);

                    const sLabel = createTextSprite(`${surahNamesTR[surahNum]} ${surahNum}:1`, true);
                    sLabel.position.set(0, 4000, 0);
                    g.add(sLabel);
                    surahGroups.push(g); scene.add(g);
                } else {
                    // Ayetler: surenin etrafƒ±nda daƒüƒ±lƒ±m
                    const totalAyahs = surahAyahCounts[surahNum];
                    const isUpper = ayahNum <= Math.ceil(totalAyahs / 2);
                    const angle = Math.random() * Math.PI * 2;
                    const dist = (Math.random() * 0.7 + 0.3) * ayahScatterR;
                    node.x = sp.x + Math.cos(angle) * dist;
                    node.z = sp.z + Math.sin(angle) * dist;
                    node.y = (isUpper ? 1 : -1) * (Math.random() * 0.8 + 0.2) * diskThickness;
                    ayahNodes.push(node);
                }
                (node.roots || []).forEach(r => { if(!rootMap.has(r)) rootMap.set(r, []); rootMap.get(r).push(idx); });
            });

            // K√∂k baƒülantƒ± √ßizgileri
            rootMap.forEach((ids, root) => {
                if (ids.length < 2) return;
                const color = new THREE.Color(getRootCSSColor(root));
                for (let i = 0; i < ids.length - 1; i++) {
                    const n1 = nodes[ids[i]]; const n2 = nodes[ids[i+1]];
                    lineV.push(n1.x, n1.y, n1.z, n2.x, n2.y, n2.z);
                    lineC.push(color.r, color.g, color.b, color.r, color.g, color.b);
                    lineNodePairs.push({ n1: n1.id, n2: n2.id, root: root });
                }
            });
            const lG = new THREE.BufferGeometry();
            lG.setAttribute('position', new THREE.Float32BufferAttribute(lineV, 3));
            lG.setAttribute('color', new THREE.Float32BufferAttribute(lineC, 3));
            lineSegments = new THREE.LineSegments(lG, new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.02 }));
            lineSegments.renderOrder = 1; scene.add(lineSegments);

            // Ayet k√ºreleri (texture'lƒ±)
            const ayahSunTex = createSunTexture(new THREE.Color(0x00f2ff), 256);
            ayahMesh = new THREE.InstancedMesh(new THREE.SphereGeometry(400, 16, 16), new THREE.MeshBasicMaterial({ map: ayahSunTex }), ayahNodes.length);
            const dum = new THREE.Object3D(); ayahNodes.forEach((a, i) => { dum.position.set(a.x, a.y, a.z); dum.updateMatrix(); ayahMesh.setMatrixAt(i, dum.matrix); });
            scene.add(ayahMesh);
            ayahNodes.forEach(a => {
                const ap = a.id.split(':');
                const lbl = createTextSprite(`${surahNamesTR[ap[0]]} ${ap[0]}:${ap[1]}`, false);
                lbl.position.set(a.x, a.y + 1200, a.z);
                lbl.visible = false;
                labelSprites.push(lbl);
                scene.add(lbl);
            });
            setTimeout(() => { if(nodes.length > 0) warpTo(nodes[0]); }, 100);
        };

        const onMouseMove = (event) => {
            if (event.target.closest('#tooltip')) return;
            const hTarget = event.target.closest('.ref-hover');
            if (hTarget) {
                const n = nodes.find(x => x.id === hTarget.dataset.id);
                if (n) { showTooltip(n, event.clientX, event.clientY); return; }
            }
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intS = raycaster.intersectObjects(surahGroups, true);
            if (intS.length > 0) {
                let o = intS[0].object; while(o && !o.userData?.nodeData) o = o.parent;
                if(o) { showTooltip(o.userData.nodeData, event.clientX, event.clientY); return; }
            }
            if (ayahMesh) {
                const intA = raycaster.intersectObject(ayahMesh);
                if (intA.length > 0) { const n = ayahNodes[intA[0].instanceId]; if(n) { showTooltip(n, event.clientX, event.clientY); return; } }
            }
            // √ñnce neon tube'lara bak (g√∂r√ºnen kalƒ±n √ßizgiler)
            if (highlightLines && highlightLines.length > 0) {
                const tubes = highlightLines.filter(m => m.userData.pair);
                const intT = raycaster.intersectObjects(tubes);
                if (intT.length > 0) {
                    const pair = intT[0].object.userData.pair;
                    if (pair) { showLineTooltip(pair, event.clientX, event.clientY); return; }
                }
            }
            // Neon yoksa arka plan √ßizgilerine bak
            if ((!highlightLines || highlightLines.length === 0) && lineSegments && lineNodePairs.length > 0) {
                raycaster.params.Line.threshold = 800;
                const intL = raycaster.intersectObject(lineSegments);
                if (intL.length > 0) {
                    const segIdx = Math.floor(intL[0].index / 2);
                    const pair = lineNodePairs[segIdx];
                    if (pair) { showLineTooltip(pair, event.clientX, event.clientY); return; }
                }
            }
            hideTooltip();
        };

        const onMouseClick = (event) => {
            if (warpActive || event.target.closest('.hud-panel') || event.target.closest('.search-results') || event.target.closest('#tooltip')) return;
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intS = raycaster.intersectObjects(surahGroups, true);
            if (intS.length > 0) {
                let o = intS[0].object; while(o && !o.userData?.nodeData) o = o.parent;
                if(o && o.userData.nodeData) { warpTo(o.userData.nodeData); return; }
            }
            // √ñnce neon tube'lara bak
            if (highlightLines && highlightLines.length > 0) {
                const tubes = highlightLines.filter(m => m.userData.pair);
                const intT = raycaster.intersectObjects(tubes);
                if (intT.length > 0) {
                    const pair = intT[0].object.userData.pair;
                    if (pair) {
                        const nd1 = nodes.find(nd => nd.id === pair.n1);
                        const nd2 = nodes.find(nd => nd.id === pair.n2);
                        if (nd1 && nd2) {
                            const d1 = camera.position.distanceToSquared(new THREE.Vector3(nd1.x, nd1.y, nd1.z));
                            const d2 = camera.position.distanceToSquared(new THREE.Vector3(nd2.x, nd2.y, nd2.z));
                            hideTooltip();
                            warpTo(d1 <= d2 ? nd2 : nd1);
                            return;
                        }
                    }
                }
            }
            // Neon yoksa arka plan √ßizgilerine bak
            if ((!highlightLines || highlightLines.length === 0) && lineSegments && lineNodePairs.length > 0) {
                raycaster.params.Line.threshold = 800;
                const intL = raycaster.intersectObject(lineSegments);
                if (intL.length > 0) {
                    const segIdx = Math.floor(intL[0].index / 2);
                    const pair = lineNodePairs[segIdx];
                    if (pair) {
                        const nd1 = nodes.find(nd => nd.id === pair.n1);
                        const nd2 = nodes.find(nd => nd.id === pair.n2);
                        if (nd1 && nd2) {
                            const d1 = camera.position.distanceToSquared(new THREE.Vector3(nd1.x, nd1.y, nd1.z));
                            const d2 = camera.position.distanceToSquared(new THREE.Vector3(nd2.x, nd2.y, nd2.z));
                            hideTooltip();
                            warpTo(d1 <= d2 ? nd2 : nd1);
                            return;
                        }
                    }
                }
            }
            let closestNode = null; let minDistance = 2500;
            nodes.forEach(n => {
                const nodePos = new THREE.Vector3(n.x, n.y, n.z);
                const distance = raycaster.ray.distanceToPoint(nodePos);
                if (distance < minDistance) { minDistance = distance; closestNode = n; }
            });
            if (closestNode) warpTo(closestNode);
        };

        const clampTooltip = (tooltip, x, y) => {
            const tw = tooltip.offsetWidth; const th = tooltip.offsetHeight;
            const vw = window.innerWidth; const vh = window.innerHeight;
            let tx = x + 25; let ty = y + 25;
            if (tx + tw > vw - 16) tx = vw - tw - 16;
            if (ty + th > vh - 16) ty = vh - th - 16;
            if (tx < 16) tx = 16; if (ty < 16) ty = 16;
            tooltip.style.left = tx + 'px'; tooltip.style.top = ty + 'px';
        };

        const showTooltip = (n, x, y) => {
            const tooltip = document.getElementById('tooltip');
            if (lastHoveredId === n.id) { clampTooltip(tooltip, x, y); return; }
            lastHoveredId = n.id;
            const highlightedText = highlightArabicText(n.text, n.roots);
            
            const rootsHtml = (n.roots || []).map(r => {
                const color = getRootCSSColor(r);
                return `
                    <div class="mini-root-tag" style="color: ${color}; border-color: ${color.replace('hsl', 'hsla').replace(')', ', 0.4)')}">
                        <span class="text-[18px] font-bold">${r}</span>
                        <span class="mini-root-pron">${getRootPron(r)}</span>
                    </div>`;
            }).join('');

            tooltip.innerHTML = `
                <div class='tooltip-header'><span class='text-[10px] font-black text-cyan-400 uppercase tracking-widest italic'>${getSurahTR(n.id)} ${n.id.split(':')[1]}</span></div>
                <p class='text-right arabic-text text-xl text-white mb-2' dir='rtl'>${highlightedText}</p>
                <div class="flex flex-wrap gap-1 mb-3">
                    ${rootsHtml}
                </div>
                <div class='h-px w-full bg-cyan-400/20 my-3'></div>
                <p class='text-[13px] leading-relaxed text-slate-300 italic'>${n.translation}</p>
            `;
            tooltip.style.display = 'block';
            clampTooltip(tooltip, x, y);
        };
        const showLineTooltip = (pair, x, y) => {
            const tooltip = document.getElementById('tooltip');
            const rootColor = getRootCSSColor(pair.root);
            const rootPron = getRootPron(pair.root);
            const s1 = pair.n1.split(':'); const s2 = pair.n2.split(':');
            const name1 = `${surahNamesTR[s1[0]]} ${s1[0]}:${s1[1]}`;
            const name2 = `${surahNamesTR[s2[0]]} ${s2[0]}:${s2[1]}`;
            // Kameraya yakƒ±n olan node = bulunduƒüun yer, uzak olan = gidilecek yer
            const nd1 = nodes.find(nd => nd.id === pair.n1);
            const nd2 = nodes.find(nd => nd.id === pair.n2);
            let farId, farName, nearName;
            if (nd1 && nd2) {
                const d1 = camera.position.distanceToSquared(new THREE.Vector3(nd1.x, nd1.y, nd1.z));
                const d2 = camera.position.distanceToSquared(new THREE.Vector3(nd2.x, nd2.y, nd2.z));
                if (d1 <= d2) { farId = pair.n2; farName = name2; nearName = name1; }
                else { farId = pair.n1; farName = name1; nearName = name2; }
            } else { farId = pair.n2; farName = name2; nearName = name1; }
            lastHoveredId = 'line_' + pair.n1 + '_' + pair.n2;
            tooltip.innerHTML = `
                <div style="font-size:11px;font-weight:900;color:#00f2ff;text-transform:uppercase;letter-spacing:0.15em;margin-bottom:8px;">K√∂k Baƒülantƒ±sƒ±</div>
                <div style="display:flex;align-items:center;gap:8px;margin-bottom:10px;">
                    <span style="color:${rootColor};font-size:20px;font-weight:bold;">${pair.root}</span>
                    <span style="color:${rootColor};font-size:12px;opacity:0.7;">${rootPron}</span>
                </div>
                <div style="font-size:10px;color:#64748b;margin-bottom:6px;">üìç ${nearName}</div>
                <div onclick="hideTooltip();warpToId('${farId}')" style="display:flex;align-items:center;gap:8px;padding:10px 14px;background:rgba(0,242,255,0.08);border:1px solid rgba(0,242,255,0.2);border-radius:8px;cursor:pointer;transition:background 0.2s;" onmouseenter="this.style.background='rgba(0,242,255,0.2)'" onmouseleave="this.style.background='rgba(0,242,255,0.08)'"><span style="color:#00f2ff;font-size:8px;">‚¨§</span><span style="color:#e2e8f0;font-size:13px;font-weight:600;">‚Üí ${farName}</span></div>`;
            tooltip.style.display = 'block';
            tooltip.style.pointerEvents = 'auto';
            clampTooltip(tooltip, x, y);
        };

        const hideTooltip = () => { const t = document.getElementById('tooltip'); t.style.display = 'none'; t.style.pointerEvents = 'none'; lastHoveredId = null; clearTimeout(hoverTimeout); stopAudio(); };
        window.hideTooltip = hideTooltip;

        let currentHudNode = null;
        let activeSpeakBtn = null;

        const speakWithBrowser = (text) => {
            if (!window.speechSynthesis) return false;
            window.speechSynthesis.cancel();
            const utter = new SpeechSynthesisUtterance(text);
            utter.lang = 'tr-TR';
            utter.rate = 0.9;
            window.speechSynthesis.speak(utter);
            return utter;
        };

        window.speakThis = async (btn, nodeId) => {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            const text = node.translation;
            if (activeSpeakBtn && activeSpeakBtn !== btn) { activeSpeakBtn.textContent = '‚ñ∂'; }
            if (currentAudio || window.speechSynthesis?.speaking) {
                stopAudio();
                window.speechSynthesis?.cancel();
                btn.textContent = '‚ñ∂';
                activeSpeakBtn = null;
                return;
            }
            activeSpeakBtn = btn;
            btn.textContent = '‚è≥';
            const success = await speakAyah(text);
            if (success && currentAudio) {
                btn.textContent = '‚èπ';
                currentAudio.onended = () => { btn.textContent = '‚ñ∂'; currentAudio = null; activeSpeakBtn = null; };
            } else {
                const utter = speakWithBrowser(text);
                if (utter) {
                    btn.textContent = '‚èπ';
                    utter.onend = () => { btn.textContent = '‚ñ∂'; activeSpeakBtn = null; };
                    utter.onerror = () => { btn.textContent = '‚ñ∂'; activeSpeakBtn = null; };
                } else {
                    btn.textContent = '‚ùå';
                    setTimeout(() => { btn.textContent = '‚ñ∂'; }, 2000);
                    activeSpeakBtn = null;
                }
            }
        };

        const updateHighlightLines = (n) => {
            if (highlightLines) { highlightLines.forEach(m => scene.remove(m)); highlightLines = null; }
            if (!n) return;
            highlightLines = [];
            const nodeIdx = nodes.findIndex(nd => nd.id === n.id);
            (n.roots || []).forEach(root => {
                const ids = rootMap.get(root);
                if (!ids) return;
                const color = new THREE.Color(getRootCSSColor(root));
                for (let i = 0; i < ids.length - 1; i++) {
                    if (ids[i] === nodeIdx || ids[i+1] === nodeIdx) {
                        const a = nodes[ids[i]]; const b = nodes[ids[i+1]];
                        const p1 = new THREE.Vector3(a.x, a.y, a.z);
                        const p2 = new THREE.Vector3(b.x, b.y, b.z);
                        const path = new THREE.LineCurve3(p1, p2);
                        const pairData = { n1: a.id, n2: b.id, root: root };
                        const tubeG = new THREE.TubeGeometry(path, 1, 40, 6, false);
                        const tubeM = new THREE.Mesh(tubeG, new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.85 }));
                        tubeM.renderOrder = 2;
                        tubeM.userData.pair = pairData;
                        scene.add(tubeM);
                        highlightLines.push(tubeM);
                        const glowM = new THREE.Mesh(tubeG, new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.15 }));
                        glowM.scale.set(2.5, 2.5, 1);
                        glowM.renderOrder = 1;
                        scene.add(glowM);
                        highlightLines.push(glowM);
                    }
                }
            });
        };

        const showHUD = (n) => {
            if (!n) return;
            currentHudNode = n;
            updateHighlightLines(n);
            const panel = document.getElementById('hud-panel');
            panel.classList.remove('hidden');
            const arabicHighlighted = highlightArabicText(n.text, n.roots);
            document.getElementById('hud-title').innerText = getSurahTR(n.id);
            document.getElementById('hud-coord').innerText = `KOORDƒ∞NAT: ${n.id}`;
            document.getElementById('hud-translation').innerText = n.translation;
            document.getElementById('hud-arabic').innerHTML = arabicHighlighted;

            const rootsCont = document.getElementById('hud-roots'); rootsCont.innerHTML = '';
            (n.roots || []).forEach(r => {
                const c = getRootCSSColor(r); const badge = document.createElement('div'); badge.className = "root-badge";
                badge.style.color = c; badge.style.borderColor = c.replace('hsl', 'hsla').replace(')', ', 0.4)');
                badge.style.backgroundColor = c.replace('hsl', 'hsla').replace(')', ', 0.1)');
                badge.innerHTML = `<span dir="rtl" class="text-2xl font-bold">${r}</span><span class="root-pron">${getRootPron(r)}</span>`;
                rootsCont.appendChild(badge);
            });

            const list = document.getElementById('related-list'); list.innerHTML = '';
            const related = []; const seen = new Set([n.id]);
            (n.roots || []).forEach(r => { (rootMap.get(r) || []).forEach(idx => { const rn = nodes[idx]; if (rn && !seen.has(rn.id)) { related.push(rn); seen.add(rn.id); } }); });
            
            let html = '';
            const grouped = related.reduce((acc, rn) => { const t = getSurahTR(rn.id); if (!acc[t]) acc[t] = []; acc[t].push(rn); return acc; }, {});
            for (const sName in grouped) {
                html += `<div class="surah-group-header"><span>${sName}</span><span>${grouped[sName].length} Ayet</span></div>`;
                grouped[sName].forEach(rn => {
                    const shared = (rn.roots || []).filter(r => (n.roots || []).includes(r));
                    html += `
                        <div class="ayah-list-item ref-hover" data-id="${rn.id}" onclick="event.stopPropagation(); warpToId('${rn.id}')">
                            <div class="flex justify-between items-center mb-1">
                                <span class="text-[11px] font-bold text-slate-100 uppercase tracking-tight">${getSurahTR(rn.id)} ${rn.id.split(':')[1]}. Ayet</span>
                                <div style="display:flex;align-items:center;gap:6px;">
                                    <button onclick="event.stopPropagation(); window.speakThis(this, '${rn.id}')" style="width:28px;height:28px;border-radius:50%;border:1px solid #00f2ff;background:rgba(0,242,255,0.1);color:#00f2ff;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:12px;flex-shrink:0;" title="Seslendir">‚ñ∂</button>
                                    <span class="text-[10px] text-cyan-500 font-mono">${rn.id}</span>
                                </div>
                            </div>
                            <div class="flex flex-wrap gap-1">
                                ${shared.map(sr => `
                                    <div class="mini-root-tag" style="color: ${getRootCSSColor(sr)}; border-color: ${getRootCSSColor(sr).replace('hsl', 'hsla').replace(')', ', 0.4)')}">
                                        <span>${sr}</span>
                                        <span class="mini-root-pron">${getRootPron(sr)}</span>
                                    </div>`).join('')}
                            </div>
                        </div>`;
                });
            }
            list.innerHTML = html || '<p class="text-xs text-slate-600 italic text-center">Baƒülantƒ± bulunamadƒ±.</p>';

            // HUD arama filtreleme
            const hudSearch = document.getElementById('hud-search');
            hudSearch.value = '';
            hudSearch.oninput = () => {
                const q = hudSearch.value.toLowerCase().trim();
                const items = list.querySelectorAll('.ayah-list-item');
                const headers = list.querySelectorAll('.surah-group-header');
                items.forEach(item => {
                    const text = item.textContent.toLowerCase();
                    item.style.display = text.includes(q) ? '' : 'none';
                });
                // Sure ba≈ülƒ±klarƒ±nƒ±, altƒ±ndaki t√ºm ayetler gizliyse gizle
                headers.forEach(h => {
                    let next = h.nextElementSibling;
                    let anyVisible = false;
                    while (next && !next.classList.contains('surah-group-header')) {
                        if (next.style.display !== 'none') anyVisible = true;
                        next = next.nextElementSibling;
                    }
                    h.style.display = anyVisible ? '' : 'none';
                });
            };
        };

        const warpTo = (node) => { 
            if(!node) return;
            hideTooltip();
            warpActive = true; warpProgress = 0; controls.enabled = false; 
            warpStart.copy(camera.position); warpTarget.set(node.x, node.y, node.z); 
            warpEnd.set(node.x + 4000, node.y + 8000, node.z + 12000);
            showHUD(node); 
        };
        window.warpToId = (id) => { const t = nodes.find(n => n.id === id); if(t) warpTo(t); };
        const animate = () => {
            requestAnimationFrame(animate);
            if (warpActive) {
                warpProgress += 0.025; const p = Math.min(warpProgress, 1);
                const ease = p < 0.5 ? 4 * p * p * p : 1 - Math.pow(-2 * p + 2, 3) / 2;
                const w = window.innerWidth, h = window.innerHeight;

                // Canvas2D hyperspace (sadece yƒ±ldƒ±zlar)
                if (p < 1) {
                    warpCanvas.style.display = 'block';
                    warpSpeed = 1 + Math.sin(p * Math.PI) * 120;
                    warpCtx.fillStyle = `rgba(0,0,0,${warpSpeed > 30 ? 0.12 : 0.3})`;
                    warpCtx.fillRect(0, 0, w, h);

                    warpCtx.lineCap = 'round';
                    for (let i = 0; i < warpStars.length; i++) {
                        const s = warpStars[i];
                        s.pz = s.z; s.z -= warpSpeed;
                        if (s.z < 1) { s.z = w; s.x = Math.random() * w * 4 - w * 2; s.y = Math.random() * h * 4 - h * 2; s.pz = s.z; }
                        const sx = (s.x / s.z) * w + warpCenterX, sy = (s.y / s.z) * h + warpCenterY;
                        const px = (s.x / s.pz) * w + warpCenterX, py = (s.y / s.pz) * h + warpCenterY;
                        const dr = 1 - s.z / w;
                        warpCtx.lineWidth = Math.max(0.2, s.size * (1 + dr * 2.5) * 0.5);
                        warpCtx.strokeStyle = `rgba(255,255,255,${Math.min(1, dr * 0.8 + 0.2)})`;
                        warpCtx.beginPath(); warpCtx.moveTo(px, py); warpCtx.lineTo(sx, sy); warpCtx.stroke();
                    }
                }

                // FOV
                if (p < 0.25) {
                    camera.fov = 65 + (p / 0.25) * 60;
                } else if (p < 0.75) {
                    camera.fov = 125;
                } else {
                    camera.fov = 125 - ((p - 0.75) / 0.25) * 60;
                }
                camera.updateProjectionMatrix();

                // Kamera hareketi
                camera.position.lerpVectors(warpStart, warpEnd, ease);
                controls.target.copy(warpTarget);

                if (p >= 1) {
                    warpActive = false; controls.enabled = true;
                    camera.fov = 65; camera.updateProjectionMatrix();
                    warpCtx.clearRect(0, 0, w, h);
                    warpCanvas.style.display = 'none';
                }
            }
            if (controls) controls.update();

            // Surah k√ºrelerini d√∂nd√ºr + glow shader time g√ºncelle
            const elapsed = performance.now() * 0.001;
            surahGroups.forEach((g, i) => {
                g.children.forEach(child => {
                    if (child.isMesh && child.material.uniforms && child.material.uniforms.time) {
                        child.material.uniforms.time.value = elapsed + i * 0.5;
                    }
                    if (child.isMesh && child.material.map) {
                        child.rotation.y = elapsed * 0.3 + i;
                        child.rotation.x = Math.sin(elapsed * 0.15 + i) * 0.2;
                    }
                });
            });

            // Ayet node'larƒ±nƒ± d√∂nd√ºr (UV offset ile)
            if (ayahMesh && ayahMesh.material.map) {
                ayahMesh.material.map.offset.x = elapsed * 0.05;
                ayahMesh.material.map.offset.y = Math.sin(elapsed * 0.08) * 0.1;
            }

            const camP = camera.position;
            labelSprites.forEach(s => { s.visible = camP.distanceTo(s.position) < 25000; });
            if (renderer) renderer.render(scene, camera);
        };
        
        document.getElementById('search-input').oninput = (e) => {
            const qRaw = e.target.value.trim();
            const results = document.getElementById('search-results');
            if (qRaw.length < 1) { results.style.display = 'none'; return; }
            const qNorm = qRaw.toLowerCase();
            const parts = qRaw.split(/[\s:]+/);
            const searchSurah = parts[0]; const searchAyah = parts[1] || "";
            let finalResults = [];
            let matchCounts = { total: 0, surahs: new Set() };
            
            Object.keys(surahNamesTR).forEach(id => {
                const sNameNorm = surahNamesTR[id].toLowerCase();
                if (id === searchSurah || sNameNorm.includes(qNorm)) {
                    if (searchAyah) {
                        const fullId = `${id}:${searchAyah}`;
                        const ayahNode = nodes.find(n => n.id === fullId);
                        if (ayahNode) { finalResults.push({ id: fullId, label: `${surahNamesTR[id]} ${searchAyah}`, sub: "AYET", type: 'ayah' }); matchCounts.total++; matchCounts.surahs.add(id); }
                    } else finalResults.push({ id: id, label: `${surahNamesTR[id]}`, sub: "SURE", type: 'surah' });
                }
            });
            nodes.filter(n => n.translation.toLowerCase().includes(qNorm)).forEach(n => {
                if (!finalResults.find(r => r.id === n.id)) finalResults.push({ id: n.id, label: `${getSurahTR(n.id)} ${n.id.split(':')[1]}`, sub: n.translation.substring(0, 50) + "...", type: 'ayah' });
                matchCounts.total++; matchCounts.surahs.add(n.id.split(':')[0]);
            });
            if (finalResults.length > 0) {
                let statsHtml = `<div class="search-stats-bar"><span>üîç ${matchCounts.total} AYET</span><span>üìç ${matchCounts.surahs.size} SURE</span></div>`;
                results.innerHTML = statsHtml + finalResults.slice(0, 200).map(r => `
                    <div class="search-item" onmousedown="selectSearch('${r.id}', '${r.type}')">
                        <div class="flex flex-col"><span class="font-bold text-slate-100 text-sm uppercase italic">${r.label}</span><span class="text-[9px] text-cyan-500 font-bold opacity-60 mt-0.5 tracking-wider">${r.sub}</span></div>
                    </div>`).join('');
                results.style.display = 'block';
            } else results.style.display = 'none';
        };
        window.selectSearch = (targetId, type) => {
            let t = (type === 'ayah') ? nodes.find(n => n.id === targetId) : nodes.find(n => n.id.split(':')[0] === targetId);
            if (t) { warpTo(t); document.getElementById('search-results').style.display = 'none'; }
        };

        document.getElementById('file-input').onchange = (e) => { const r = new FileReader(); r.onload = (ev) => processData(JSON.parse(ev.target.result)); r.readAsText(e.target.files[0]); };
        document.getElementById('close-hud').onclick = () => { document.getElementById('hud-panel').classList.add('hidden'); stopAudio(); };
        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (warpCanvas) {
                const dpr = window.devicePixelRatio || 1;
                warpCanvas.width = window.innerWidth * dpr;
                warpCanvas.height = window.innerHeight * dpr;
                warpCanvas.style.width = window.innerWidth + 'px';
                warpCanvas.style.height = window.innerHeight + 'px';
                warpCtx.scale(dpr, dpr);
                warpCenterX = window.innerWidth / 2;
                warpCenterY = window.innerHeight / 2;
            }
        };
        
        window.onload = init;
    </script>
</body>
</html>