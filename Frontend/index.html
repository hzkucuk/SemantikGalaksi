<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kur'an-ƒ± Kerim Kelime K√∂k Uzayƒ±</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><circle cx='16' cy='16' r='14' fill='%23000' stroke='%2300f2ff' stroke-width='2'/><circle cx='16' cy='16' r='4' fill='%2300f2ff'/></svg>">
    <script>const _w=console.warn;console.warn=(...a)=>{if(typeof a[0]==='string'&&a[0].includes('tailwindcss.com'))return;_w.apply(console,a);};</script>
    <script src="tailwind.min.js"></script>
    <script src="three.min.js"></script>
    <script src="OrbitControls.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=Amiri&display=swap');
        
        body { margin: 0; background: #000; color: white; font-family: 'Inter', sans-serif; overflow: hidden; }
        canvas { display: block; }

        .hud-panel {
            background: rgba(0, 5, 12, 0.98);
            backdrop-filter: blur(40px);
            border-left: 3px solid #00f2ff;
            box-shadow: -25px 0 100px rgba(0,0,0,1);
            pointer-events: auto;
            -webkit-overflow-scrolling: touch;
        }

        @media (max-width: 767px) {
            .hud-panel { border-left: none; border-top: 3px solid #00f2ff; }
            .root-badge { min-width: 60px; padding: 8px; }
            .root-pron { font-size: 7px; }
            .ayah-list-item { padding: 10px; }
            .ayah-list-item:hover { transform: none; }
        }

        .search-results {
            position: absolute; top: 100%; left: 0; right: 0;
            background: rgba(0, 8, 15, 0.98); border: 1px solid rgba(0, 242, 255, 0.3);
            border-radius: 20px; margin-top: 10px; max-height: min(480px, 60vh); overflow-y: auto;
            display: none; z-index: 100; backdrop-filter: blur(20px);
        }
        .search-stats-bar {
            padding: 12px 20px; background: rgba(0, 242, 255, 0.15);
            border-bottom: 1px solid rgba(0, 242, 255, 0.3);
            font-size: 10px; font-weight: 900; color: #00f2ff;
            text-transform: uppercase; letter-spacing: 2px;
            display: flex; justify-content: space-between;
            position: sticky; top: 0; z-index: 110;
        }

        .neon-title {
            color: #00f2ff; font-weight: 900; text-transform: uppercase;
            font-style: italic; letter-spacing: -1px;
            text-shadow: 0 0 20px rgba(0, 242, 255, 0.6);
        }

        .root-badge {
            padding: 10px; border-radius: 12px; min-width: 75px;
            background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1);
            display: flex; flex-direction: column; align-items: center; 
            box-shadow: 0 0 15px currentColor;
        }
        .root-pron { font-size: 8px; font-weight: 900; letter-spacing: 1.5px; margin-top: 4px; opacity: 0.8; text-transform: uppercase; color: white; }

        .arabic-text { font-family: 'Amiri', serif; line-height: 1.8; word-spacing: 4px; }
        .root-highlight { 
            text-shadow: 0 0 8px currentColor, 0 0 20px currentColor; 
            font-weight: bold;
            display: inline-block; transition: all 0.4s;
            border-bottom: 2px solid currentColor;
            background: rgba(255,255,255,0.06);
            padding: 0 2px;
            border-radius: 3px;
        }

        #tooltip {
            position: fixed; display: none; pointer-events: none;
            background: rgba(0, 5, 12, 0.98); border: 1px solid rgba(0, 242, 255, 0.4);
            padding: 24px; max-width: min(520px, calc(100vw - 32px)); z-index: 1000;
            max-height: calc(100vh - 32px); overflow-y: auto;
            box-shadow: 0 25px 80px rgba(0,0,0,1); backdrop-filter: blur(25px);
            border-radius: 1.5rem;
        }

        .ayah-list-item { 
            padding: 14px; border-radius: 15px; background: rgba(255,255,255,0.02); 
            border: 1px solid rgba(255,255,255,0.05); margin-bottom: 10px; 
            cursor: pointer; transition: all 0.3s; 
        }
        .ayah-list-item:hover { background: rgba(0, 242, 255, 0.1); border-color: #00f2ff; transform: translateX(10px); }
        
        .mini-root-tag { 
            font-size: 11px; padding: 4px 8px; border-radius: 6px; border: 1px solid; 
            margin-right: 5px; margin-top: 6px; display: inline-flex; 
            flex-direction: column; align-items: center; font-weight: 900; 
            background: rgba(0,0,0,0.4); line-height: 1.1;
        }
        .mini-root-pron { 
            font-size: 7px; letter-spacing: 0.5px; opacity: 0.8; 
            margin-top: 2px; color: #fff; text-transform: uppercase; font-family: 'Inter', sans-serif;
        }

        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-thumb { background: #00f2ff; border-radius: 10px; }

        .loading-screen {
            position: fixed; inset: 0; background: #000; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s;
        }
    </style>
</head>
<body>

    <div id="loading-screen" class="loading-screen">
        <div class="w-16 h-16 border-4 border-cyan-500 border-t-transparent rounded-full animate-spin mb-6 shadow-[0_0_20px_rgba(6,182,212,0.5)]"></div>
        <p class="text-cyan-500 font-mono tracking-[0.5em] text-xs uppercase animate-pulse">Y√ºkleniyor...</p>
    </div>

    <div id="warp-flash" class="fixed inset-0 bg-cyan-400 pointer-events-none opacity-0 z-[999]"></div>
    <div id="tooltip"></div>

    <div class="fixed top-0 w-full z-50 p-3 md:p-6 flex flex-col md:flex-row justify-between items-center bg-gradient-to-b from-black to-transparent gap-2 md:gap-4">
        <div class="text-center md:text-left">
            <h1 class="text-xl md:text-3xl neon-title">Kur'an-ƒ± Kerim Kelime K√∂k Uzayƒ±</h1>
            <p class="text-[8px] md:text-[9px] text-cyan-800 font-mono tracking-[0.4em] uppercase">3D Semantik Analiz</p>
        </div>
        <div class="flex flex-col sm:flex-row gap-2 md:gap-3 w-full md:w-auto relative">
            <div class="w-full md:w-[32rem] relative">
                <input type="text" id="search-input" placeholder="Sure, Koordinat veya Meal Ara..." class="bg-black/90 border border-white/10 rounded-full px-4 md:px-7 py-2.5 md:py-3 w-full outline-none focus:border-cyan-400 text-xs md:text-sm font-bold text-white shadow-2xl transition-all">
                <div id="search-results" class="search-results"></div>
            </div>
            <label id="upload-label" class="bg-cyan-950 hover:bg-cyan-600 border border-cyan-400/30 px-4 md:px-8 py-2.5 md:py-3 rounded-full font-black text-[10px] md:text-[11px] cursor-pointer shadow-xl transition-all uppercase text-white tracking-widest text-center">
                VERƒ∞ Y√úKLE
                <input type="file" id="file-input" class="hidden" accept=".json">
            </label>
        </div>
    </div>

    <div id="hud-panel" class="fixed inset-2 top-20 md:inset-auto md:top-28 md:bottom-8 md:left-8 md:w-[28rem] hud-panel rounded-2xl md:rounded-[3.5rem] p-4 md:p-10 hidden z-40 overflow-y-auto border border-white/5 transition-all duration-300">
        <button id="close-hud" class="absolute top-3 right-3 md:top-10 md:right-10 w-9 h-9 md:w-10 md:h-10 flex items-center justify-center bg-white/5 rounded-full text-slate-500 hover:text-white transition-all z-50">‚úï</button>
        <div id="hud-content">
            <div class="mb-6 md:mb-8 border-b border-white/10 pb-6 md:pb-8">
                <h2 id="hud-title" class="text-3xl md:text-4xl neon-title">SURE</h2>
                <p id="hud-coord" class="text-[9px] md:text-[10px] text-slate-500 font-mono tracking-[0.4em] mt-2 uppercase opacity-60">KOORDƒ∞NAT: 0:0</p>
            </div>

            <div class="bg-slate-900/60 p-4 md:p-8 rounded-xl md:rounded-[2.5rem] mb-4 md:mb-8 border border-white/5 shadow-inner">
                <p id="hud-arabic" class="text-right text-xl md:text-3xl arabic-text text-white leading-relaxed" dir="rtl"></p>
                <div class="h-px w-full bg-cyan-400/20 my-3 md:my-6"></div>
                <p id="hud-translation" class="text-sm md:text-lg text-slate-200 italic font-light leading-relaxed"></p>
            </div>

            <div class="mb-6 md:mb-8">
                <h3 class="text-[8px] md:text-[9px] font-black text-slate-600 uppercase tracking-[0.4em] mb-4 md:mb-6 italic text-center">S√ºl√¢si K√∂k Analizi</h3>
                <div id="hud-roots" class="flex flex-wrap justify-center gap-2 md:gap-4"></div>
            </div>

            <div class="pb-8">
                <h3 class="text-[9px] font-black text-cyan-950 uppercase tracking-[0.4em] mb-4 italic text-center">Semantik Baƒülantƒ±lar</h3>
                <div id="related-list"></div>
            </div>
        </div>
    </div>

    <script>
        /** GLOBAL VARIABLES **/
        let scene, camera, renderer, ayahMesh, starField, lineSegments, controls;
        let nodes = []; let surahGroups = []; let ayahNodes = []; let rootMap = new Map(); let labelSprites = [];
        let raycaster = new THREE.Raycaster(); let mouse = new THREE.Vector2();
        let currentAudio = null; let audioCache = new Map(); let hoverTimeout = null; let lastHoveredId = null;
        let warpActive = false; let warpProgress = 0; let warpStart = new THREE.Vector3(); let warpEnd = new THREE.Vector3(); let warpTarget = new THREE.Vector3();
        let isAudioLoading = false;
        
        // --- ‚ö†Ô∏è API KEY BURAYA GELECEK ---
        const apiKey = "AIzaSyABgS_0iV7VnlZY5MwqxpM5sksMmqh9LFA"; 

        const arabicToLatinMap = {
            'ÿß': 'E', 'ÿ£': 'E', 'ÿ•': 'E', 'ÿ¢': 'E', 'ÿ®': 'B', 'ÿ™': 'T', 'ÿ´': 'TH', 'ÿ¨': 'C', 'ÿ≠': 'H', 'ÿÆ': 'KH', 
            'ÿØ': 'D', 'ÿ∞': 'DH', 'ÿ±': 'R', 'ÿ≤': 'Z', 'ÿ≥': 'S', 'ÿ¥': '≈û', 'ÿµ': 'S', 
            'ÿ∂': 'D', 'ÿ∑': 'T', 'ÿ∏': 'Z', 'ÿπ': 'A', 'ÿ∫': 'GH', 'ŸÅ': 'F', 'ŸÇ': 'K', 
            'ŸÉ': 'K', 'ŸÑ': 'L', 'ŸÖ': 'M', 'ŸÜ': 'N', 'Ÿá': 'H', 'Ÿà': 'V', 'Ÿä': 'Y', 
            'ÿ°': 'E', 'ÿ§': 'W', 'ÿ¶': 'Y', 'ÿ©': 'T', ' ' : '-'
        };

        const surahNamesTR = {
            "1":"F√¢tiha","2":"Bakara","3":"√Çl-i ƒ∞mr√¢n","4":"Nis√¢","5":"M√¢ide","6":"En'√¢m","7":"A'r√¢f","8":"Enf√¢l","9":"Tevbe","10":"Y√ªnus",
            "11":"H√ªd","12":"Y√ªsuf","13":"Ra'd","14":"ƒ∞br√¢h√Æm","15":"Hicr","16":"Nahl","17":"ƒ∞sr√¢","18":"Kehf","19":"Meryem","20":"T√¢-H√¢",
            "21":"Enbiy√¢","22":"Hac","23":"M√º'min√ªn","24":"N√ªr","25":"Furk√¢n","26":"≈ûuar√¢","27":"Neml","28":"Kasas","29":"Ankeb√ªt","30":"R√ªm",
            "31":"Lokm√¢n","32":"Secde","33":"Ahz√¢b","34":"Sebe'","35":"F√¢tƒ±r","36":"Y√¢-S√Æn","37":"S√¢ff√¢t","38":"S√¢d","39":"Z√ºmer","40":"M√º'min",
            "41":"Fussilet","42":"≈û√ªr√¢","43":"Zuhruf","44":"Duh√¢n","45":"C√¢siye","46":"Ahk√¢f","47":"Muhammed","48":"Fetih","49":"Hucur√¢t","50":"K√¢f",
            "51":"Z√¢riy√¢t","52":"T√ªr","53":"Necm","54":"Kamer","55":"Rahm√¢n","56":"V√¢kƒ±a","57":"Had√Æd","58":"M√ºc√¢dele","59":"Ha≈ür","60":"M√ºmtehine",
            "61":"Saff","62":"Cuma","63":"M√ºn√¢fik√ªn","64":"Teg√¢bun","65":"Tal√¢k","66":"Tahr√Æm","67":"M√ºlk","68":"Kalem","69":"H√¢kka","70":"Me√¢ric",
            "71":"N√ªh","72":"Cin","73":"M√ºzzemmil","74":"M√ºddessir","75":"Kƒ±y√¢met","76":"ƒ∞ns√¢n","77":"M√ºrsel√¢t","78":"Nebe","79":"N√¢zi√¢t","80":"Abese",
            "81":"Tekv√Ær","82":"ƒ∞nfit√¢r","83":"Mutaffif√Æn","84":"ƒ∞n≈üik√¢k","85":"Bur√ªc","86":"T√¢rƒ±k","87":"A'l√¢","88":"G√¢≈üiye","89":"Fecr","90":"Beled",
            "91":"≈ûems","92":"Leyl","93":"Duh√¢","94":"ƒ∞n≈üir√¢h","95":"T√Æn","96":"Alak","97":"Kadir","98":"Beyyine","99":"Zilz√¢l","100":"√Çdiy√¢t",
            "101":"K√¢ria","102":"Tek√¢s√ºr","103":"Asr","104":"H√ºmeze","105":"F√Æl","106":"Kurey≈ü","107":"M√¢√ªn","108":"Kevser","109":"K√¢fir√ªn","110":"Nasr",
            "111":"Mesed","112":"ƒ∞hl√¢s","113":"Felak","114":"N√¢s"
        };

        const getSurahTR = (id) => surahNamesTR[id.split(':')[0]] || "Sure " + id.split(':')[0];
        const getRootCSSColor = (root) => {
            let h = 0; for (let i = 0; i < root.length; i++) h = (h << 5) - h + root.charCodeAt(i);
            return `hsl(${Math.abs(h * 137.5) % 360}, 100%, 60%)`;
        };
        const getRootPron = (root) => {
            if(!root) return "";
            return root.split('').filter(c => c !== ' ').map(char => arabicToLatinMap[char] || char).join('-');
        };

        const highlightArabicText = (text, roots) => {
            if (!roots || roots.length === 0) return text;
            const diacritics = /[Ÿã-ŸüŸ∞€ñ-€≠]/g;
            const alifV = /[ÿßÿ£ÿ•ÿ¢ÿ°]/g;
            let clean = ""; let map = [];
            for (let i = 0; i < text.length; i++) {
                if (!text[i].match(diacritics)) { map.push(i); clean += text[i]; }
            }
            let res = text; let matches = [];
            roots.forEach(root => {
                if(!root) return;
                const color = getRootCSSColor(root);
                const cleanRoot = root.trim().replace(diacritics, '').replace(alifV, 'ÿß').replace(/\s/g, '');
                if (!cleanRoot) return;
                let src = clean.replace(alifV, 'ÿß');
                let start = 0;
                while ((start = src.indexOf(cleanRoot, start)) !== -1) {
                    const os = map[start];
                    const oe = map[start + cleanRoot.length] ? map[start + cleanRoot.length] - 1 : text.length - 1;
                    matches.push({ s: os, e: oe, color: color });
                    start += cleanRoot.length;
                }
            });
            matches.sort((a, b) => b.s - a.s);
            matches.forEach(m => {
                const sub = res.substring(m.s, m.e + 1);
                res = res.slice(0, m.s) + `<span class="root-highlight" style="color: ${m.color}">${sub}</span>` + res.slice(m.e + 1);
            });
            return res;
        };

        const stopAudio = () => { if (currentAudio) { currentAudio.pause(); currentAudio.currentTime = 0; currentAudio = null; } };
        const playAudio = (url) => { if (currentAudio) stopAudio(); currentAudio = new Audio(url); currentAudio.play().catch(e => {}); };

        const speakAyah = async (text) => {
            if (!apiKey) { console.warn('TTS: API key tanƒ±mlanmamƒ±≈ü'); return false; }
            stopAudio();
            if (audioCache.has(text)) { playAudio(audioCache.get(text)); return true; }
            if (isAudioLoading) return false;
            isAudioLoading = true;
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: `Say in Turkish: ${text}` }] }],
                        generationConfig: { responseModalities: ["AUDIO"], speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Charon" } } } },
                        model: "gemini-2.5-flash-preview-tts"
                    })
                });
                if (!response.ok) { console.error('TTS API hata:', response.status, response.statusText); return false; }
                const result = await response.json();
                const part = result.candidates?.[0]?.content?.parts?.[0];
                if (part?.inlineData?.data) {
                    const raw = window.atob(part.inlineData.data);
                    const pcm = new Uint8Array(raw.length);
                    for (let i = 0; i < raw.length; i++) pcm[i] = raw.charCodeAt(i);
                    const url = URL.createObjectURL(new Blob([pcmToWav(pcm, 24000)], { type: 'audio/wav' }));
                    audioCache.set(text, url);
                    playAudio(url);
                    return true;
                }
                console.warn('TTS: Ses verisi alƒ±namadƒ±', result);
                return false;
            } catch (err) { console.error('TTS hata:', err); return false; } finally { isAudioLoading = false; }
        };

        const pcmToWav = (pcm, rate) => {
            const b = new ArrayBuffer(44 + pcm.length); const v = new DataView(b);
            const s = (o, str) => { for (let i = 0; i < str.length; i++) v.setUint8(o + i, str.charCodeAt(i)); };
            s(0, 'RIFF'); v.setUint32(4, 36 + pcm.length, true); s(8, 'WAVE'); s(12, 'fmt '); v.setUint32(16, 16, true);
            v.setUint16(20, 1, true); v.setUint16(22, 1, true); v.setUint32(24, rate, true); v.setUint32(28, rate * 2, true);
            v.setUint16(32, 2, true); v.setUint16(34, 16, true); s(36, 'data'); v.setUint32(40, pcm.length, true);
            for (let i = 0; i < pcm.length; i++) v.setUint8(44 + i, pcm[i]); return b;
        };

        const init = () => {
            scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 1, 100000000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); document.body.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true;
            scene.add(new THREE.AmbientLight(0xffffff, 1.4));
            const starGeom = new THREE.BufferGeometry(); const starPos = [];
            for(let i=0; i<60000; i++) starPos.push((Math.random()-0.5)*10000000, (Math.random()-0.5)*10000000, (Math.random()-0.5)*10000000);
            starGeom.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            starField = new THREE.Points(starGeom, new THREE.PointsMaterial({ color: 0x888888, size: 1600, transparent: true, opacity: 0.5 }));
            scene.add(starField); camera.position.set(0, 100000, 350000);
            renderer.domElement.addEventListener('click', onMouseClick); 
            window.addEventListener('mousemove', onMouseMove); 
            animate();
            
            // --- OTOMATƒ∞K VERƒ∞ √áEKME (GitHub Pages Desteƒüi) ---
            fetchDataAutomatically();
        };

        const fetchDataAutomatically = async () => {
            try {
                const response = await fetch('quran_data.json');
                if (response.ok) {
                    const data = await response.json();
                    processData(data);
                    document.getElementById('upload-label').style.display = 'none';
                }
            } catch (e) {
                console.log("JSON bulunamadƒ±, manuel y√ºkleme bekleniyor.");
            } finally {
                setTimeout(() => {
                    document.getElementById('loading-screen').style.opacity = '0';
                    setTimeout(() => document.getElementById('loading-screen').style.display = 'none', 800);
                }, 1000);
            }
        };

        const createTextSprite = (text, isSurah) => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512; canvas.height = 64;
            ctx.font = `bold ${isSurah ? 40 : 30}px Inter, sans-serif`;
            ctx.fillStyle = isSurah ? '#00f2ff' : '#ffffff';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            const texture = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
            const sprite = new THREE.Sprite(mat);
            const s = isSurah ? 20000 : 10000;
            sprite.scale.set(s, s * (canvas.height / canvas.width), 1);
            return sprite;
        };

        const processData = (data) => {
            if (!data || !data.nodes) return;
            surahGroups.forEach(g => scene.remove(g)); if(ayahMesh) scene.remove(ayahMesh); if(lineSegments) scene.remove(lineSegments);
            labelSprites.forEach(s => scene.remove(s));
            surahGroups = []; ayahNodes = []; rootMap.clear(); labelSprites = [];
            nodes = data.nodes.map(n => ({ ...n, roots: Array.isArray(n.roots) ? n.roots : [] }));
            const surahIds = [...new Set(nodes.map(n => n.id.split(':')[0]))].sort((a,b) => parseInt(a)-parseInt(b));
            const dim = Math.ceil(Math.sqrt(surahIds.length)); const gridS = 280000; const ayahYS = 22000;
            const lineV = []; const lineC = [];
            nodes.forEach((node, idx) => {
                const parts = node.id.split(':'); const sIdx = surahIds.indexOf(parts[0]);
                node.x = (sIdx % dim) * gridS - (dim * gridS / 2);
                node.z = Math.floor(sIdx / dim) * gridS - (dim * gridS / 2);
                node.y = - (parseInt(parts[1]) * ayahYS);
                if (parseInt(parts[1]) === 1) {
                    const g = new THREE.Group(); g.position.set(node.x, node.y, node.z); g.userData = { nodeData: node };
                    const c = new THREE.Color(getRootCSSColor(parts[0]));
                    const p = new THREE.Mesh(new THREE.SphereGeometry(7500, 32, 32), new THREE.MeshStandardMaterial({ color: c, emissive: c, emissiveIntensity: 2 }));
                    g.add(p);
                    const sLabel = createTextSprite(`${surahNamesTR[parts[0]]} ${parts[0]}:${parts[1]}`, true);
                    sLabel.position.set(0, 12000, 0);
                    g.add(sLabel);
                    surahGroups.push(g); scene.add(g);
                } else { ayahNodes.push(node); }
                (node.roots || []).forEach(r => { if(!rootMap.has(r)) rootMap.set(r, []); rootMap.get(r).push(idx); });
            });

            rootMap.forEach((ids, root) => {
                if (ids.length < 2) return;
                const color = new THREE.Color(getRootCSSColor(root));
                for (let i = 0; i < ids.length - 1; i++) {
                    const n1 = nodes[ids[i]]; const n2 = nodes[ids[i+1]];
                    lineV.push(n1.x, n1.y, n1.z, n2.x, n2.y, n2.z);
                    lineC.push(color.r, color.g, color.b, color.r, color.g, color.b);
                }
            });
            const lG = new THREE.BufferGeometry(); lG.setAttribute('position', new THREE.Float32BufferAttribute(lineV, 3));
            lG.setAttribute('color', new THREE.Float32BufferAttribute(lineC, 3));
            lineSegments = new THREE.LineSegments(lG, new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.8 }));
            lineSegments.renderOrder = 1; scene.add(lineSegments);

            ayahMesh = new THREE.InstancedMesh(new THREE.SphereGeometry(1400, 16, 16), new THREE.MeshStandardMaterial({ color: 0x00f2ff, transparent: true, opacity: 0.85 }), ayahNodes.length);
            const dum = new THREE.Object3D(); ayahNodes.forEach((a, i) => { dum.position.set(a.x, a.y, a.z); dum.updateMatrix(); ayahMesh.setMatrixAt(i, dum.matrix); });
            scene.add(ayahMesh);
            ayahNodes.forEach(a => {
                const ap = a.id.split(':');
                const lbl = createTextSprite(`${surahNamesTR[ap[0]]} ${ap[0]}:${ap[1]}`, false);
                lbl.position.set(a.x, a.y + 3500, a.z);
                lbl.visible = false;
                labelSprites.push(lbl);
                scene.add(lbl);
            });
            setTimeout(() => { if(nodes.length > 0) warpTo(nodes[0]); }, 100);
        };

        const onMouseMove = (event) => {
            const hTarget = event.target.closest('.ref-hover');
            if (hTarget) {
                const n = nodes.find(x => x.id === hTarget.dataset.id);
                if (n) { showTooltip(n, event.clientX, event.clientY); return; }
            }
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intS = raycaster.intersectObjects(surahGroups, true);
            if (intS.length > 0) {
                let o = intS[0].object; while(o && !o.userData?.nodeData) o = o.parent;
                if(o) { showTooltip(o.userData.nodeData, event.clientX, event.clientY); return; }
            }
            if (ayahMesh) {
                const intA = raycaster.intersectObject(ayahMesh);
                if (intA.length > 0) { const n = ayahNodes[intA[0].instanceId]; if(n) { showTooltip(n, event.clientX, event.clientY); return; } }
            }
            hideTooltip();
        };

        const onMouseClick = (event) => {
            if (warpActive || event.target.closest('.hud-panel') || event.target.closest('.search-results')) return;
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intS = raycaster.intersectObjects(surahGroups, true);
            if (intS.length > 0) {
                let o = intS[0].object; while(o && !o.userData?.nodeData) o = o.parent;
                if(o && o.userData.nodeData) { warpTo(o.userData.nodeData); return; }
            }
            let closestNode = null; let minDistance = 9000; 
            nodes.forEach(n => {
                const nodePos = new THREE.Vector3(n.x, n.y, n.z);
                const distance = raycaster.ray.distanceToPoint(nodePos);
                if (distance < minDistance) { minDistance = distance; closestNode = n; }
            });
            if (closestNode) warpTo(closestNode);
        };

        const clampTooltip = (tooltip, x, y) => {
            const tw = tooltip.offsetWidth; const th = tooltip.offsetHeight;
            const vw = window.innerWidth; const vh = window.innerHeight;
            let tx = x + 25; let ty = y + 25;
            if (tx + tw > vw - 16) tx = vw - tw - 16;
            if (ty + th > vh - 16) ty = vh - th - 16;
            if (tx < 16) tx = 16; if (ty < 16) ty = 16;
            tooltip.style.left = tx + 'px'; tooltip.style.top = ty + 'px';
        };

        const showTooltip = (n, x, y) => {
            const tooltip = document.getElementById('tooltip');
            if (lastHoveredId === n.id) { clampTooltip(tooltip, x, y); return; }
            lastHoveredId = n.id;
            const highlightedText = highlightArabicText(n.text, n.roots);
            
            const rootsHtml = (n.roots || []).map(r => {
                const color = getRootCSSColor(r);
                return `
                    <div class="mini-root-tag" style="color: ${color}; border-color: ${color.replace('hsl', 'hsla').replace(')', ', 0.4)')}">
                        <span class="text-[11px] font-bold">${r}</span>
                        <span class="mini-root-pron">${getRootPron(r)}</span>
                    </div>`;
            }).join('');

            tooltip.innerHTML = `
                <div class='tooltip-header'><span class='text-[10px] font-black text-cyan-400 uppercase tracking-widest italic'>${getSurahTR(n.id)} ${n.id.split(':')[1]}</span></div>
                <p class='text-right arabic-text text-xl text-white mb-2' dir='rtl'>${highlightedText}</p>
                <div class="flex flex-wrap gap-1 mb-3">
                    ${rootsHtml}
                </div>
                <div class='h-px w-full bg-cyan-400/20 my-3'></div>
                <p class='text-[13px] leading-relaxed text-slate-300 italic'>${n.translation}</p>
            `;
            tooltip.style.display = 'block';
            clampTooltip(tooltip, x, y);
        };
        const hideTooltip = () => { document.getElementById('tooltip').style.display = 'none'; lastHoveredId = null; clearTimeout(hoverTimeout); stopAudio(); };

        let currentHudNode = null;
        let activeSpeakBtn = null;

        const speakWithBrowser = (text) => {
            if (!window.speechSynthesis) return false;
            window.speechSynthesis.cancel();
            const utter = new SpeechSynthesisUtterance(text);
            utter.lang = 'tr-TR';
            utter.rate = 0.9;
            window.speechSynthesis.speak(utter);
            return utter;
        };

        window.speakThis = async (btn, nodeId) => {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            const text = node.translation;
            if (activeSpeakBtn && activeSpeakBtn !== btn) { activeSpeakBtn.textContent = '‚ñ∂'; }
            if (currentAudio || window.speechSynthesis?.speaking) {
                stopAudio();
                window.speechSynthesis?.cancel();
                btn.textContent = '‚ñ∂';
                activeSpeakBtn = null;
                return;
            }
            activeSpeakBtn = btn;
            btn.textContent = '‚è≥';
            const success = await speakAyah(text);
            if (success && currentAudio) {
                btn.textContent = '‚èπ';
                currentAudio.onended = () => { btn.textContent = '‚ñ∂'; currentAudio = null; activeSpeakBtn = null; };
            } else {
                const utter = speakWithBrowser(text);
                if (utter) {
                    btn.textContent = '‚èπ';
                    utter.onend = () => { btn.textContent = '‚ñ∂'; activeSpeakBtn = null; };
                    utter.onerror = () => { btn.textContent = '‚ñ∂'; activeSpeakBtn = null; };
                } else {
                    btn.textContent = '‚ùå';
                    setTimeout(() => { btn.textContent = '‚ñ∂'; }, 2000);
                    activeSpeakBtn = null;
                }
            }
        };

        const showHUD = (n) => {
            if (!n) return;
            currentHudNode = n;
            const panel = document.getElementById('hud-panel');
            panel.classList.remove('hidden');
            const arabicHighlighted = highlightArabicText(n.text, n.roots);
            document.getElementById('hud-title').innerText = getSurahTR(n.id);
            document.getElementById('hud-coord').innerText = `KOORDƒ∞NAT: ${n.id}`;
            document.getElementById('hud-translation').innerText = n.translation;
            document.getElementById('hud-arabic').innerHTML = arabicHighlighted;

            const rootsCont = document.getElementById('hud-roots'); rootsCont.innerHTML = '';
            (n.roots || []).forEach(r => {
                const c = getRootCSSColor(r); const badge = document.createElement('div'); badge.className = "root-badge";
                badge.style.color = c; badge.style.borderColor = c.replace('hsl', 'hsla').replace(')', ', 0.4)');
                badge.style.backgroundColor = c.replace('hsl', 'hsla').replace(')', ', 0.1)');
                badge.innerHTML = `<span dir="rtl" class="text-xl font-bold">${r}</span><span class="root-pron">${getRootPron(r)}</span>`;
                rootsCont.appendChild(badge);
            });

            const list = document.getElementById('related-list'); list.innerHTML = '';
            const related = []; const seen = new Set([n.id]);
            (n.roots || []).forEach(r => { (rootMap.get(r) || []).forEach(idx => { const rn = nodes[idx]; if (rn && !seen.has(rn.id)) { related.push(rn); seen.add(rn.id); } }); });
            
            let html = '';
            const grouped = related.reduce((acc, rn) => { const t = getSurahTR(rn.id); if (!acc[t]) acc[t] = []; acc[t].push(rn); return acc; }, {});
            for (const sName in grouped) {
                html += `<div class="surah-group-header"><span>${sName}</span><span>${grouped[sName].length} Ayet</span></div>`;
                grouped[sName].forEach(rn => {
                    const shared = (rn.roots || []).filter(r => (n.roots || []).includes(r));
                    html += `
                        <div class="ayah-list-item ref-hover" data-id="${rn.id}" onclick="event.stopPropagation(); warpToId('${rn.id}')">
                            <div class="flex justify-between items-center mb-1">
                                <span class="text-[11px] font-bold text-slate-100 uppercase tracking-tight">${getSurahTR(rn.id)} ${rn.id.split(':')[1]}. Ayet</span>
                                <div style="display:flex;align-items:center;gap:6px;">
                                    <button onclick="event.stopPropagation(); window.speakThis(this, '${rn.id}')" style="width:28px;height:28px;border-radius:50%;border:1px solid #00f2ff;background:rgba(0,242,255,0.1);color:#00f2ff;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:12px;flex-shrink:0;" title="Seslendir">‚ñ∂</button>
                                    <span class="text-[10px] text-cyan-500 font-mono">${rn.id}</span>
                                </div>
                            </div>
                            <div class="flex flex-wrap gap-1">
                                ${shared.map(sr => `
                                    <div class="mini-root-tag" style="color: ${getRootCSSColor(sr)}; border-color: ${getRootCSSColor(sr).replace('hsl', 'hsla').replace(')', ', 0.4)')}">
                                        <span>${sr}</span>
                                        <span class="mini-root-pron">${getRootPron(sr)}</span>
                                    </div>`).join('')}
                            </div>
                        </div>`;
                });
            }
            list.innerHTML = html || '<p class="text-xs text-slate-600 italic text-center">Baƒülantƒ± bulunamadƒ±.</p>';
        };

        const warpTo = (node) => { 
            if(!node) return;
            hideTooltip();
            warpActive = true; warpProgress = 0; controls.enabled = false; 
            warpStart.copy(camera.position); warpTarget.set(node.x, node.y, node.z); 
            warpEnd.set(node.x + 8000, node.y + 4000, node.z + 15000); 
            showHUD(node); 
        };
        window.warpToId = (id) => { const t = nodes.find(n => n.id === id); if(t) warpTo(t); };
        const animate = () => {
            requestAnimationFrame(animate);
            if (warpActive) {
                warpProgress += 0.025; const p = Math.min(warpProgress, 1);
                camera.fov = 65 + (Math.sin(p * Math.PI) * 55); camera.updateProjectionMatrix();
                document.getElementById('warp-flash').style.opacity = Math.sin(p * Math.PI) * 0.4;
                camera.position.lerpVectors(warpStart, warpEnd, p); controls.target.lerp(warpTarget, p);
                if(p >= 1) { warpActive = false; controls.enabled = true; camera.fov = 65; camera.updateProjectionMatrix(); }
            }
            if (controls) controls.update();
            const camP = camera.position;
            labelSprites.forEach(s => { s.visible = camP.distanceTo(s.position) < 80000; });
            if (renderer) renderer.render(scene, camera);
        };
        
        document.getElementById('search-input').oninput = (e) => {
            const qRaw = e.target.value.trim();
            const results = document.getElementById('search-results');
            if (qRaw.length < 1) { results.style.display = 'none'; return; }
            const qNorm = qRaw.toLowerCase();
            const parts = qRaw.split(/[\s:]+/);
            const searchSurah = parts[0]; const searchAyah = parts[1] || "";
            let finalResults = [];
            let matchCounts = { total: 0, surahs: new Set() };
            
            Object.keys(surahNamesTR).forEach(id => {
                const sNameNorm = surahNamesTR[id].toLowerCase();
                if (id === searchSurah || sNameNorm.includes(qNorm)) {
                    if (searchAyah) {
                        const fullId = `${id}:${searchAyah}`;
                        const ayahNode = nodes.find(n => n.id === fullId);
                        if (ayahNode) { finalResults.push({ id: fullId, label: `${surahNamesTR[id]} ${searchAyah}`, sub: "AYET", type: 'ayah' }); matchCounts.total++; matchCounts.surahs.add(id); }
                    } else finalResults.push({ id: id, label: `${surahNamesTR[id]}`, sub: "SURE", type: 'surah' });
                }
            });
            nodes.filter(n => n.translation.toLowerCase().includes(qNorm)).forEach(n => {
                if (!finalResults.find(r => r.id === n.id)) finalResults.push({ id: n.id, label: `${getSurahTR(n.id)} ${n.id.split(':')[1]}`, sub: n.translation.substring(0, 50) + "...", type: 'ayah' });
                matchCounts.total++; matchCounts.surahs.add(n.id.split(':')[0]);
            });
            if (finalResults.length > 0) {
                let statsHtml = `<div class="search-stats-bar"><span>üîç ${matchCounts.total} AYET</span><span>üìç ${matchCounts.surahs.size} SURE</span></div>`;
                results.innerHTML = statsHtml + finalResults.slice(0, 200).map(r => `
                    <div class="search-item" onmousedown="selectSearch('${r.id}', '${r.type}')">
                        <div class="flex flex-col"><span class="font-bold text-slate-100 text-sm uppercase italic">${r.label}</span><span class="text-[9px] text-cyan-500 font-bold opacity-60 mt-0.5 tracking-wider">${r.sub}</span></div>
                    </div>`).join('');
                results.style.display = 'block';
            } else results.style.display = 'none';
        };
        window.selectSearch = (targetId, type) => {
            let t = (type === 'ayah') ? nodes.find(n => n.id === targetId) : nodes.find(n => n.id.split(':')[0] === targetId);
            if (t) { warpTo(t); document.getElementById('search-results').style.display = 'none'; }
        };

        document.getElementById('file-input').onchange = (e) => { const r = new FileReader(); r.onload = (ev) => processData(JSON.parse(ev.target.result)); r.readAsText(e.target.files[0]); };
        document.getElementById('close-hud').onclick = () => { document.getElementById('hud-panel').classList.add('hidden'); stopAudio(); };
        window.onresize = () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
        
        window.onload = init;
    </script>
</body>
</html>